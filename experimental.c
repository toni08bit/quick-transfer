/*
 *  tls_file_transfer.c (this is a prototype which was generated by AI)
 *
 *  A simple TLS-secured file-transmitting tool, analogous to the provided
 *  Python example. Uses OpenSSL in C for TLS encryption and sockets for
 *  network communication.
 *
 *  Build/Run instructions:
 *  1. Install OpenSSL and development headers (e.g., libssl-dev on Debian/Ubuntu).
 *  2. Compile:
 *     gcc -Wall -Wextra -o tls_file_transfer tls_file_transfer.c -lssl -lcrypto
 *  3. Run as client:
 *     ./tls_file_transfer <host> <port> <6-digit-code> <filename>
 *  4. Run as server:
 *     ./tls_file_transfer -s [optional: -p <port>]
 *
 *  Note: This example uses a self-signed certificate generated on-the-fly by
 *        calling `openssl req ...` via `system()` calls. For more robust or
 *        repeated usage, you should handle certificate generation differently.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <fcntl.h>
#include <errno.h>
#include <time.h>

#include <openssl/ssl.h>
#include <openssl/err.h>

#define BUFFER_SIZE         (8 * 1024)
#define SPEED_PROBE_SIZE    200
#define PROGRESS_BAR_WIDTH  45
#define PROGRESS_INTERVAL   0.2   /* seconds */

static double last_progress_time = 0;
static size_t last_progress_length = 0;

/* ------------------------------------------------------------------------
 * Utility: size_string
 * Formats the file size into a human-readable string (B, KB, MB, GB, TB, PB).
 */
static void size_string(double bytes, char *out_buf, size_t out_buf_sz)
{
    const char *units[] = {"B", "KB", "MB", "GB", "TB", "PB"};
    int idx = 0;
    while (bytes >= 1024.0 && idx < 5) {
        bytes /= 1024.0;
        idx++;
    }
    snprintf(out_buf, out_buf_sz, "%.2f %s", bytes, units[idx]);
}

/* ------------------------------------------------------------------------
 * Utility: time_string
 * Formats an integer number of seconds into "xh ym zs" or "ym zs".
 */
static void time_string(double seconds, char *out_buf, size_t out_buf_sz)
{
    int h = (int)seconds / 3600;
    int m = ((int)seconds % 3600) / 60;
    int s = (int)seconds % 60;

    if (h > 0) {
        snprintf(out_buf, out_buf_sz, "%dh %dm %ds", h, m, s);
    } else {
        snprintf(out_buf, out_buf_sz, "%dm %ds", m, s);
    }
}

/* ------------------------------------------------------------------------
 * Utility: random_digits
 * Generates a random numeric string of length `digits`.
 * In a production environment, consider using a cryptographically
 * strong RNG. For demonstration, we seed rand() with time(0).
 */
static void random_digits(char *out_buf, size_t digits)
{
    srand(time(NULL));
    for (size_t i = 0; i < digits; i++) {
        out_buf[i] = '0' + (rand() % 10);
    }
    out_buf[digits] = '\0';
}

/* ------------------------------------------------------------------------
 * Utility: avg_probes
 * Computes the average of non-zero elements in a floating array.
 */
static double avg_probes(double *probe_list, int size)
{
    double total = 0.0;
    int count = 0;
    for (int i = 0; i < size; i++) {
        if (probe_list[i] > 0.0) {
            total += probe_list[i];
            count++;
        }
    }
    if (count == 0) return 0.0;
    return total / count;
}

/* ------------------------------------------------------------------------
 * Utility: current_time_s
 * Returns current time in seconds as a double for simple performance tracking.
 */
static double current_time_s(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (double)ts.tv_sec + ((double)ts.tv_nsec / 1000000000.0);
}

/* ------------------------------------------------------------------------
 * Utility: print_progress
 * Similar to the Python function. Only prints if PROGRESS_INTERVAL has elapsed.
 */
static void print_progress(double speed, size_t transmitted, size_t total)
{
    double now = current_time_s();
    if ((last_progress_time > 0) && ((now - last_progress_time) < PROGRESS_INTERVAL)) {
        return;
    }
    last_progress_time = now;

    double progress = (double)transmitted / (double)total;
    double seconds_left = 0.0;
    if (speed > 0.0) {
        seconds_left = ((double)(total - transmitted)) / speed;
    }

    char speed_str[64];
    size_string(speed, speed_str, sizeof(speed_str));

    char time_str[64];
    time_string(seconds_left, time_str, sizeof(time_str));

    int bar_fill = (int)(progress * PROGRESS_BAR_WIDTH);
    if (bar_fill > PROGRESS_BAR_WIDTH) {
        bar_fill = PROGRESS_BAR_WIDTH;
    }

    char bar[PROGRESS_BAR_WIDTH + 1];
    memset(bar, '#', bar_fill);
    memset(bar + bar_fill, '-', PROGRESS_BAR_WIDTH - bar_fill);
    bar[PROGRESS_BAR_WIDTH] = '\0';

    /* Construct the line */
    char line[512];
    snprintf(line, sizeof(line),
             "\r    [%s] %6.2f%% %10s/s %s",
             bar,
             progress * 100.0,
             speed_str,
             time_str);

    /* Erase remainder if shorter than last print */
    size_t line_len = strlen(line);
    if (line_len < last_progress_length) {
        memset(line + line_len, ' ', last_progress_length - line_len);
        line[last_progress_length] = '\0';
    }
    last_progress_length = strlen(line);

    /* Print to stdout */
    fputs(line, stdout);
    fflush(stdout);
}

/* ------------------------------------------------------------------------
 * Utility: generate_cert
 * Calls `openssl req` to produce a self-signed cert for demonstration.
 * In a real application, you might generate certificates with the OpenSSL API
 * or provide your own.
 */
static int generate_cert(const char *certfile, const char *keyfile)
{
    fprintf(stdout, "[*] Generating self-signed certificate...\n");
    fflush(stdout);

    char cmd[1024];
    snprintf(cmd, sizeof(cmd),
             "openssl req -x509 -nodes -newkey rsa:2048 "
             "-keyout %s -out %s -days 1 -subj \"/CN=localhost\" 2>/dev/null",
             keyfile, certfile);

    int ret = system(cmd);
    if (ret != 0) {
        fprintf(stderr, "[!] Failed to generate certificate via openssl.\n");
        return -1;
    }
    return 0;
}

/* ------------------------------------------------------------------------
 * client_main
 * Connects to the server with TLS, sends a file along with a code, filename,
 * and size. Awaits server confirmation.
 */
static int client_main(const char *host, int port, const char *code, const char *file_path)
{
    /* Get file size and name */
    struct stat st;
    if (stat(file_path, &st) < 0) {
        perror("[!] Error retrieving file stats");
        return -1;
    }
    size_t file_size = (size_t)st.st_size;

    const char *slash_ptr = strrchr(file_path, '/');
    const char *filename = (slash_ptr != NULL) ? (slash_ptr + 1) : file_path;

    /* Print info */
    {
        char size_buf[64];
        size_string((double)file_size, size_buf, sizeof(size_buf));
        printf("[*] Sending file '%s' (%s)\n", filename, size_buf);
        printf("[*] Connecting to %s:%d over TLS...\n", host, port);
    }

    SSL_library_init();
    SSL_load_error_strings();

    /* Create SSL context */
    const SSL_METHOD *method = TLS_client_method();
    SSL_CTX *ctx = SSL_CTX_new(method);
    if (!ctx) {
        fprintf(stderr, "[!] Failed to create SSL_CTX.\n");
        return -1;
    }
    /* Insecure: skip certificate verification for demonstration */
    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

    /* Create TCP socket */
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("[!] socket");
        SSL_CTX_free(ctx);
        return -1;
    }

    struct hostent *he = gethostbyname(host);
    if (!he) {
        fprintf(stderr, "[!] gethostbyname failed.\n");
        close(sockfd);
        SSL_CTX_free(ctx);
        return -1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    memcpy(&server_addr.sin_addr, he->h_addr_list[0], he->h_length);

    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("[!] connect");
        close(sockfd);
        SSL_CTX_free(ctx);
        return -1;
    }

    SSL *ssl = SSL_new(ctx);
    SSL_set_fd(ssl, sockfd);

    if (SSL_connect(ssl) <= 0) {
        fprintf(stderr, "[!] SSL connection failed.\n");
        SSL_free(ssl);
        close(sockfd);
        SSL_CTX_free(ctx);
        return -1;
    }

    /* Send code (3 bytes, e.g. 6-digit code in integer form) */
    {
        int code_val = atoi(code);
        unsigned char code_bytes[3];
        code_bytes[0] = (code_val >> 16) & 0xFF;
        code_bytes[1] = (code_val >> 8) & 0xFF;
        code_bytes[2] = code_val & 0xFF;
        if (SSL_write(ssl, code_bytes, 3) != 3) {
            fprintf(stderr, "[!] Failed to send code.\n");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(sockfd);
            SSL_CTX_free(ctx);
            return -1;
        }
    }

    /* Send filename length (1 byte), then filename, then file_size (8 bytes) */
    {
        unsigned char fname_len = (unsigned char)strlen(filename);
        if (SSL_write(ssl, &fname_len, 1) != 1) {
            fprintf(stderr, "[!] Failed to send filename length.\n");
            goto client_err;
        }
        if (SSL_write(ssl, filename, fname_len) != fname_len) {
            fprintf(stderr, "[!] Failed to send filename.\n");
            goto client_err;
        }
        unsigned long long fs = (unsigned long long)file_size;
        unsigned char fs_bytes[8];
        for (int i = 0; i < 8; i++) {
            fs_bytes[7 - i] = fs & 0xFF;
            fs >>= 8;
        }
        if (SSL_write(ssl, fs_bytes, 8) != 8) {
            fprintf(stderr, "[!] Failed to send file size.\n");
            goto client_err;
        }
    }

    /* Wait for server's OK (0x01) */
    {
        unsigned char resp;
        int n = SSL_read(ssl, &resp, 1);
        if (n <= 0 || resp != 0x01) {
            fprintf(stderr, "[!] The server has declined file transfer.\n");
            goto client_err;
        }
    }

    /* Send file data with progress */
    {
        FILE *fp = fopen(file_path, "rb");
        if (!fp) {
            perror("[!] fopen");
            goto client_err;
        }

        size_t local_cursor = 0;
        static double speed_probes[SPEED_PROBE_SIZE];
        memset(speed_probes, 0, sizeof(speed_probes));
        int probe_cursor = 0;
        double last_transfer = 0.0;

        while (1) {
            unsigned char buffer[4096];
            size_t read_bytes = fread(buffer, 1, sizeof(buffer), fp);
            if (read_bytes == 0) {
                if (feof(fp)) break;
                if (ferror(fp)) {
                    fprintf(stderr, "[!] File read error.\n");
                    fclose(fp);
                    goto client_err;
                }
            }
            if (read_bytes > 0) {
                ssize_t written = SSL_write(ssl, buffer, read_bytes);
                if (written <= 0) {
                    fprintf(stderr, "[!] SSL write error.\n");
                    fclose(fp);
                    goto client_err;
                }
                double now = current_time_s();
                local_cursor += (size_t)written;
                if (last_transfer > 0.0) {
                    double delta = now - last_transfer;
                    if (delta > 0.0) {
                        double speed = (double)written / delta;
                        speed_probes[probe_cursor] = speed;
                        probe_cursor = (probe_cursor + 1) % SPEED_PROBE_SIZE;
                    }
                }
                last_transfer = now;
                print_progress(avg_probes(speed_probes, SPEED_PROBE_SIZE), local_cursor, file_size);
            }
        }
        fclose(fp);
    }

    printf("\n[+] File transfer complete, waiting for confirmation...\n");

    /* Read final confirmation (0x01) */
    {
        unsigned char resp;
        int n = SSL_read(ssl, &resp, 1);
        if (n == 1 && resp == 0x01) {
            printf("[+] The server has confirmed file transfer.\n");
        } else {
            printf("[!] No confirmation from server.\n");
        }
    }

    printf("[+] Connection closed.\n");

    /* Cleanup */
    SSL_shutdown(ssl);
    SSL_free(ssl);
    close(sockfd);
    SSL_CTX_free(ctx);
    return 0;

client_err:
    SSL_shutdown(ssl);
    SSL_free(ssl);
    close(sockfd);
    SSL_CTX_free(ctx);
    return -1;
}

/* ------------------------------------------------------------------------
 * server_main
 * Generates random code, sets up a listening TCP socket, wraps it in TLS.
 * Receives an incoming connection, reads code, filename, size, and receives
 * file data.
 */
static int server_main(int port)
{
    /* Generate 6-digit code (for demonstration) */
    char secret_code[7];
    random_digits(secret_code, 6);
    printf("[*] Generated 6-digit code: %s\n", secret_code);

    /* Generate or reuse certificate/key files */
    const char *certfile = "transfer-cert.pem";
    const char *keyfile  = "transfer-key.pem";
    if (generate_cert(certfile, keyfile) != 0) {
        return -1;
    }

    /* If port == 0, we let the OS assign a random port */
    SSL_library_init();
    SSL_load_error_strings();

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("[!] socket");
        return -1;
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port   = htons(port);
    serv_addr.sin_addr.s_addr = INADDR_ANY;

    int optval = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

    if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("[!] bind");
        close(sockfd);
        return -1;
    }

    if (listen(sockfd, 1) < 0) {
        perror("[!] listen");
        close(sockfd);
        return -1;
    }

    /* Retrieve assigned port if requested port was 0 */
    socklen_t addr_len = sizeof(serv_addr);
    if (getsockname(sockfd, (struct sockaddr *)&serv_addr, &addr_len) == 0) {
        printf("[*] Server listening on port %d.\n", ntohs(serv_addr.sin_port));
    }

    SSL_CTX *ctx = SSL_CTX_new(TLS_server_method());
    if (!ctx) {
        fprintf(stderr, "[!] Failed to create SSL_CTX.\n");
        close(sockfd);
        return -1;
    }
    if (SSL_CTX_use_certificate_file(ctx, certfile, SSL_FILETYPE_PEM) <= 0) {
        fprintf(stderr, "[!] Failed to load cert file.\n");
        SSL_CTX_free(ctx);
        close(sockfd);
        return -1;
    }
    if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) <= 0) {
        fprintf(stderr, "[!] Failed to load key file.\n");
        SSL_CTX_free(ctx);
        close(sockfd);
        return -1;
    }
    /* Insecure: skip client authentication for demonstration */
    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

    while (1) {
        printf("[*] Waiting for connection...\n");
        struct sockaddr_in cli_addr;
        socklen_t cli_len = sizeof(cli_addr);
        int newsock = accept(sockfd, (struct sockaddr *)&cli_addr, &cli_len);
        if (newsock < 0) {
            perror("[!] accept");
            continue;
        }

        SSL *ssl = SSL_new(ctx);
        SSL_set_fd(ssl, newsock);

        if (SSL_accept(ssl) <= 0) {
            fprintf(stderr, "[!] SSL handshake error.\n");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(newsock);
            continue;
        }

        /* Read 3-byte code */
        unsigned char code_bytes[3];
        int n = SSL_read(ssl, code_bytes, 3);
        if (n != 3) {
            fprintf(stderr, "[!] No code received, closing connection.\n");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(newsock);
            continue;
        }
        printf("[+] Client authenticated successfully.\n");
        /* (In an actual application, you would verify code against `secret_code`.) */

        /* Read filename length, then filename, then file_size (8 bytes) */
        unsigned char fname_len;
        n = SSL_read(ssl, &fname_len, 1);
        if (n != 1) {
            fprintf(stderr, "[!] Could not read filename length.\n");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(newsock);
            continue;
        }
        char filename[256];
        if (fname_len >= sizeof(filename)) {
            fprintf(stderr, "[!] Filename too large.\n");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(newsock);
            continue;
        }
        n = SSL_read(ssl, filename, fname_len);
        if (n != fname_len) {
            fprintf(stderr, "[!] Could not read filename.\n");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(newsock);
            continue;
        }
        filename[fname_len] = '\0';

        unsigned char fs_bytes[8];
        n = SSL_read(ssl, fs_bytes, 8);
        if (n != 8) {
            fprintf(stderr, "[!] Could not read file size.\n");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(newsock);
            continue;
        }
        unsigned long long file_size = 0;
        for (int i = 0; i < 8; i++) {
            file_size = (file_size << 8) | fs_bytes[i];
        }

        /* Send OK (0x01) */
        {
            unsigned char ok = 0x01;
            SSL_write(ssl, &ok, 1);
        }

        {
            char size_buf[64];
            size_string((double)file_size, size_buf, sizeof(size_buf));
            printf("[+] Receiving file: '%s' (%s)\n", filename, size_buf);
        }

        size_t local_cursor = 0;
        static double speed_probes[SPEED_PROBE_SIZE];
        memset(speed_probes, 0, sizeof(speed_probes));
        int probe_cursor = 0;
        double last_transfer = 0.0;

        /* For security, ensure we do not traverse out of the current directory, etc.
         * In this example, we simply check if `filename` contains any suspicious path.
         */
        if (strstr(filename, "..") != NULL) {
            fprintf(stderr, "[!] Client provided an invalid path.\n");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(newsock);
            continue;
        }

        FILE *fp = fopen(filename, "wb");
        if (!fp) {
            perror("[!] fopen");
            SSL_shutdown(ssl);
            SSL_free(ssl);
            close(newsock);
            continue;
        }

        while (local_cursor < file_size) {
            size_t to_read = file_size - local_cursor;
            if (to_read > BUFFER_SIZE) to_read = BUFFER_SIZE;

            unsigned char buffer[BUFFER_SIZE];
            n = SSL_read(ssl, buffer, (int)to_read);
            if (n <= 0) {
                fprintf(stderr, "[!] Connection was interrupted or error.\n");
                fclose(fp);
                goto close_socket;
            }
            fwrite(buffer, 1, n, fp);

            double now = current_time_s();
            local_cursor += n;
            if (last_transfer > 0.0) {
                double delta = now - last_transfer;
                if (delta > 0.0) {
                    double speed = (double)n / delta;
                    speed_probes[probe_cursor] = speed;
                    probe_cursor = (probe_cursor + 1) % SPEED_PROBE_SIZE;
                }
            }
            last_transfer = now;
            print_progress(avg_probes(speed_probes, SPEED_PROBE_SIZE), local_cursor, (size_t)file_size);
        }

        fclose(fp);

        /* Send final confirmation (0x01) */
        {
            unsigned char ok = 0x01;
            SSL_write(ssl, &ok, 1);
        }

        printf("\n[+] File transfer complete, confirmed.\n");
    close_socket:
        SSL_shutdown(ssl);
        SSL_free(ssl);
        close(newsock);
        printf("[+] Closed connection.\n");
    }

    SSL_CTX_free(ctx);
    close(sockfd);
    return 0;
}

/* ------------------------------------------------------------------------
 * Main entry: usage:
 *
 *   - As client:
 *       ./tls_file_transfer <host> <port> <6-digit-code> <filename>
 *
 *   - As server:
 *       ./tls_file_transfer -s [-p <port>]
 *
 */
int main(int argc, char **argv)
{
    if (argc >= 2 && strcmp(argv[1], "-s") == 0) {
        /* Server mode */
        int port = 0; /* 0 means random ephemeral port */
        int i = 2;
        while (i < argc) {
            if (strcmp(argv[i], "-p") == 0 && i + 1 < argc) {
                port = atoi(argv[i + 1]);
                i += 2;
                continue;
            }
            i++;
        }
        return server_main(port);
    } else {
        /* Client mode */
        if (argc < 5) {
            fprintf(stderr,
                    "Usage (client): %s <host> <port> <6-digit-code> <filename>\n",
                    argv[0]);
            return 1;
        }
        const char *host     = argv[1];
        int port             = atoi(argv[2]);
        const char *code     = argv[3];
        const char *filePath = argv[4];
        return client_main(host, port, code, filePath);
    }
}
